// This file is generated by Simplicity Studio.  Please do not edit manually.
//
//

// Enclosing macro to prevent multiple inclusion
#ifndef __THREAD_CALLBACKS__
#define __THREAD_CALLBACKS__


#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include EMBER_AF_API_STACK
#include EMBER_AF_API_EMBER_TYPES
#include EMBER_AF_API_HAL
#include EMBER_AF_API_SIM_EEPROM
#include EMBER_AF_API_TFTP_BOOTLOADER


/** @brief Main Application Entry Point
 *
 * This is the main application entry point. All applications
 * must implement this function.
 */
int main(MAIN_FUNCTION_PARAMETERS);

/** @brief A callback called in interrupt context whenever a button
 * changes its state.
 *
 * @appusage Must be implemented by the application.  This function should
 * contain the functionality to be executed in response to changes of state
 * in each of the buttons, or callbacks to the appropriate functionality.
 *
 * @param button  The button which has changed state, either BUTTON0 or BUTTON1
 * as defined in the appropriate BOARD_HEADER.
 *
 * @param state   The new state of the button referenced by the button parameter,
 * either ::BUTTON_PRESSED if the button has been pressed or ::BUTTON_RELEASED if
 * the button has been released.
 */
void halButtonIsr(uint8_t button, uint8_t state);

/**
 * @brief Handler called whenever the radio is powered on.
 */
void halRadioPowerUpHandler(void);

/**
 * @brief Handler called whenever the radio is powered off.
 */
void halRadioPowerDownHandler(void);

/** @brief Ok To Sleep
 *
 * This function is called by the Idle/Sleep plugin before sleeping.  It is
 * called with interrupts disabled.  The application should return true if the
 * device may sleep or false otherwise.
 *
 * @param durationMs The maximum duration in milliseconds that the device will
 * sleep.
 */
bool emberAfPluginIdleSleepOkToSleepCallback(uint32_t durationMs);

/** @brief Wake Up
 *
 * This function is called by the Idle/Sleep plugin after sleeping.
 *
 * @param durationMs The duration in milliseconds that the device slept.
 */
void emberAfPluginIdleSleepWakeUpCallback(uint32_t durationMs);

/** @brief Ok To Idle
 *
 * This function is called by the Idle/Sleep plugin before idling.  It is called
 * with interrupts disabled.  The application should return true if the device
 * may idle or false otherwise.
 *
 * @param durationMs The maximum duration in milliseconds that the device will
 * idle.
 */
bool emberAfPluginIdleSleepOkToIdleCallback(uint32_t durationMs);

/** @brief Active
 *
 * This function is called by the Idle/Sleep plugin after idling.
 *
 * @param durationMs The duration in milliseconds that the device idled.
 */
void emberAfPluginIdleSleepActiveCallback(uint32_t durationMs);

/** @brief Mark Application Buffers
 *
 * This function is called when the application must mark its buffers.  Buffers
 * that are not marked will be reclaimed by the stack.
 */
void emberAfMarkApplicationBuffersCallback(void);

/** @brief Network Status
 *
 * This function is called when the network status changes.
 */
void emberAfNetworkStatusCallback(EmberNetworkStatus newNetworkStatus,
                                  EmberNetworkStatus oldNetworkStatus,
                                  EmberJoinFailureReason reason);

/** @brief Main
 *
 * This function is called immediately after the application starts executing
 * and can be used to perform initialization that should occur before any other
 * components are initialized.
 */
void emberAfMainCallback(MAIN_FUNCTION_PARAMETERS);

/** @brief Init
 *
 * This function is called after the stack initializes and can be used to
 * perform any additional initialization required at stack startup.  On SoCs,
 * this will generally be called only once: at system startup.  On hosts, this
 * will be called when the NCP initializes, and may be called multiple times
 * during the lifetime of the host application.
 */
void emberAfInitCallback(void);

/** @brief Tick
 *
 * This function is called in each iteration of the main application loop and
 * can be used to perform periodic functions.  The frequency with which this
 * function is called depends on how quickly the main loop runs.  If the
 * application blocks at any time during the main loop, this function will not
 * be called until execution resumes.  On SoC platforms, sleeping and idling
 * will block.  On Unix hosts, process yielding (e.g., via select) will block.
 */
void emberAfTickCallback(void);

/** @brief The Simulated EEPROM callback function, implemented by the
 * application.
 *
 * @param status  An ::EmberStatus error code indicating one of the conditions
 * described below.
 *
 * This callback will report an EmberStatus of
 * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN whenever a token is set and a page needs
 * to be erased.  If the main application loop does not periodically
 * call halSimEepromErasePage(), it is best to then erase a page in
 * response to ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN.
 *
 * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_ERASE_PAGE_RED
 * when the pages <i>must</i> be erased to prevent data loss.
 * halSimEepromErasePage() needs to be called until it returns 0 to indicate
 * there are no more pages that need to be erased.  Ignoring
 * this indication and not erasing the pages will cause dropping the new data
 * trying to be written.
 *
 * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_FULL when
 * the new data cannot be written due to unerased pages.  <b>Not erasing
 * pages regularly, not erasing in response to
 * ::EMBER_SIM_EEPROM_ERASE_PAGE_GREEN, or not erasing in response to
 * ::EMBER_SIM_EEPROM_ERASE_PAGE_RED will cause
 * ::EMBER_SIM_EEPROM_FULL and the new data will be lost!.</b>  Any future
 * write attempts will be lost as well.
 *
 * This callback will report an EmberStatus of ::EMBER_SIM_EEPROM_REPAIRING
 * when the Simulated EEPROM needs to repair itself.  While there's nothing
 * for an app to do when the SimEE is going to repair itself (SimEE has to
 * be fully functional for the rest of the system to work), alert the
 * application to the fact that repairing is occuring.  There are debugging
 * scenarios where an app might want to know that repairing is happening;
 * such as monitoring frequency.
 * @note  Common situations will trigger an expected repair, such as using
 *        a new chip or changing token definitions.
 *
 * If the callback ever reports the status ::EMBER_ERR_FLASH_WRITE_INHIBITED or
 * ::EMBER_ERR_FLASH_VERIFY_FAILED, this indicates a catastrophic failure in
 * flash writing, meaning either the address being written is not empty or the
 * write itself has failed.  If ::EMBER_ERR_FLASH_WRITE_INHIBITED is
 * encountered, the function ::halInternalSimEeRepair(false) should be called
 * and the chip should then be reset to allow proper initialization to recover.
 * If ::EMBER_ERR_FLASH_VERIFY_FAILED is encountered the Simulated EEPROM (and
 * tokens) on the specific chip with this error should not be trusted anymore.
 *
 */
void halSimEepromCallback(EmberStatus status);

bool emberVerifyBootloadRequest(const TftpBootloaderBootloadRequest *request);

// This function can be used to hook an external memory allocator into the
// stack. It will be called when we need to allocate large packets. If a value
// other than NULL is returned that pointer will be used to store packet data.
// You must also fill in the objectRef parameter with whatever reference you
// would like passed to the emberFreeMemoryForPacketHandler() when we're done
// with this memory. If you set the objectRef to NULL then the free handler will
// not be called.
void *emberAllocateMemoryForPacketHandler(uint32_t size, void **objectRef);

// This handler is called when freeing memory allocated with
// emberAllocateMemoryForPacketHandler(). You will be passed the reference that was
// supplied when allocating the memory. If you passed NULL as the objectRef
// value then this callback is not called.
void emberFreeMemoryForPacketHandler(void *objectRef);

// Applications that use buffers must mark them by defining this function.
// The stack uses this when reclaiming unused buffers.
void emberMarkApplicationBuffersHandler(void);

/** @brief A callback that allows the application to send a message in
  * response to a poll from a child.
  *
  * This function is called when a child polls,
  * provided that the pending message flag is set for that child
  * (see ::emberSetMessageFlag(). The message should be sent to the child
  * using ::emberSendUnicast() with the ::EMBER_APS_OPTION_POLL_RESPONSE option.
  *
  * If the application includes ::emberPollHanlder(), it must
  * define EMBER_APPLICATION_HAS_POLL_HANDLER in its CONFIGURATION_HEADER.
  *
  * @param childId           The ID of the child that is requesting data.
  *
  * @param transmitExpected  true if the child is expecting an application-
  *     supplied data message.  false otherwise.
  *
  */
void emberPollHandler(EmberNodeId childId, bool transmitExpected);

/**
 * @brief Application callback for emberSendDiagnosticQuery().
 *
 * @param status The return status.
 *
 * @param remoteAddress   The remote address that sent the answer.
 * 
 * @param payload The raw payload.
 *
 * @param payloadLength payload's length.
 */
void emberDiagnosticAnswerHandler(EmberStatus status,
                                  const EmberIpv6Address *remoteAddress,
                                  const uint8_t *payload,
                                  uint8_t payloadLength);

void emberCoapMessageHandler(EmberCoapMessage *message);

void emberIpIncomingBeaconHandler(PacketHeader header);

/** @brief  Application callback for an incoming ICMP message.
 *
 * @param ipHeader        Pointer to an IPV6 buffer
 */
void emberIncomingIcmpHandler(Ipv6Header *ipHeader);

/** @brief  Reports an incoming beacon during an active scan. */
void emberActiveScanHandler(const EmberMacBeaconData *beaconData);

/** @brief
 * This is called when a SLAAC or DHCP address has been configured or timed out.
 * A valid lifetime of zero means that the address is no longer available.
 *
 * @param address            the address on the DHCP server (16 bytes)
 * @param preferredLifetime  the preferred lifetime of the address (in seconds)
 * @param validLifetime      the valid lifetime of the address (in seconds)
 * @param addressFlags       address configuration flags (EMBER_GLOBAL_ADDRESS_*)
 */
void emberAddressConfigurationChangeHandler(const EmberIpv6Address *address,
                                            uint32_t preferredLifetime,
                                            uint32_t validLifetime,
                                            uint8_t addressFlags);

/** @brief A callback that indicates whether the attach process was
 * successfully initiated via a prior call to ::emberAttachToNetwork().
 * The status argument is either EMBER_SUCCESS, or EMBER_INVALID_CALL
 * if attach was called when the network status was not
 * EMBER_JOINED_NETWORK_NO_PARENT, or while an attach was underway.
 */
void emberAttachToNetworkReturn(EmberStatus status);

/** @brief Return call for emberBecomeCommissioner().  The status is
 * EMBER_SUCCESS if a petition was sent or EMBER_ERR_FATAL if some
 * temporary resource shortage prevented doing so.
 */
void emberBecomeCommissionerReturn(EmberStatus status);

/** @brief Provides the result of a call to emberChangeNodeType():
 * either EMBER_SUCCESS, or EMBER_INVALID_CALL.
 */
void emberChangeNodeTypeReturn(EmberStatus status);

/** @brief Provides the result of a call to emberAllowNativeCommissioner():
 * either EMBER_SUCCESS or EMBER_INVALID_CALL.
 */
void emberAllowNativeCommissionerReturn(EmberStatus status);

/** @brief Provides the result of a call to emberSetCommissionerKey():
 * either EMBER_SUCCESS or EMBER_INVALID_CALL.
 */
void emberSetCommissionerKeyReturn(EmberStatus status);

/**
 * @brief Provides the result of a call to emberCommissionNetwork.
 *
 * Returns EMBER_SUCCESS if successful
 *         EMBER_BAD_ARGUMENT if any of the options are wrong
 *         EMBER_INVALID_CALL if the node is already on a network
 *
 * @param status Whether the call to emberCommissionNetwork was successful
 */
void emberCommissionNetworkReturn(EmberStatus status);

/** @brief Reports on the current commissioner state.
 *
 * @param flags    A combination of zero or more of the following:
 * - EMBER_HAVE_COMMISSIONER           a commissioner is active in the network
 * - EMBER_AM_COMMISSIONER             this device is the active commissioner
 * - EMBER_JOINING_ENABLED             joining is enabled
 * - EMBER_JOINING_WITH_EUI_STEERING   steering data restricts which devices can
 *                                     join.  if not set, no restriction, any
 *                                     device can join.  (significant only when
 *                                     EMBER_JOINING_ENABLED is set)
 *
 * @param commissionerName    The name of the active commissioner, or
 *                            NULL if there is none or the name is not
 *                            known.
 *
 * @param commissionerNameLength    The length of commissonerName.
 */
void emberCommissionerStatusHandler(uint16_t flags,
                                    const uint8_t *commissionerName,
                                    uint8_t commissionerNameLength);

/** @brief Provides the result of a call to ::emberConfigureGateway */
void emberConfigureGatewayReturn(EmberStatus status);

/** @brief Provides the result of a call to ::emberConfigureExternalRoute */
void emberConfigureExternalRouteReturn(EmberStatus status);

/** @brief A callback invoked to inform the application of the
 * occurrence of an event defined by EmberCounterType, for example,
 * transmissions and receptions at different layers of the stack.
 *
 * The application must define EMBER_APPLICATION_HAS_COUNTER_HANDLER
 * in its CONFIGURATION_HEADER to use this.
 * This function may be called in ISR context, so processing should
 * be kept to a minimum.
 *
 * @param type       The type of the event.
 * @param increment  Specify the increase in the counter's tally.
 *
 */
void emberCounterHandler(EmberCounterType type, uint16_t increment);

/** @brief A callback invoked to query the application for the
 * countervalue of an event defined by EmberCounterType.
 *
 * The application must define EMBER_APPLICATION_HAS_COUNTER_VALUE_HANDLER
 * in its CONFIGURATION_HEADER to use this.
 *
 * @param   type       The type of the event.
 * @returns The counter's tally.
 *
 */
uint16_t emberCounterValueHandler(EmberCounterType type);

/** @brief NCP handler called to process a custom message from the Host.
 *
 * @param message message received
 * @param messageLength length of message
 */
void emberCustomHostToNcpMessageHandler(const uint8_t *message,
                                        uint8_t messageLength);

/** @brief Host handler called to process a custom message from the NCP.
 *
 * @param message message received
 * @param messageLength length of message
 */
void emberCustomNcpToHostMessageHandler(const uint8_t *message,
                                        uint8_t messageLength);

/** @brief For a sleepy end device, report how long the chip went to deep sleep.
 * In a NCP + host setup, the stack reports this to the host app.
 */
void emberDeepSleepCompleteHandler(uint16_t sleepDuration);

/** @brief Provides the result of a call to emberDeepSleep(). */
void emberDeepSleepReturn(EmberStatus status);

/** @brief
 * This is called when the stack knows about a new dhcp server or if
 * a dhcp server has become unavailable.
 *
 * "available" means the DHCP server can offer us an address if
 * requested.
 *
 * @param prefix                  dhcp server prefix
 * @param prefixLengthInBits      length in bits of the prefix
 * @param available               whether this dhcp server is available
 */
void emberDhcpServerChangeHandler(const uint8_t *prefix,
                                  uint8_t prefixLengthInBits,
                                  bool available);

/** @brief  Reports the maximum RSSI value measured on the channel.
  *
  * @param channel  The 802.15.4 channel on which the RSSI value was measured.
  *
  * @param maxRssiValue  The maximum RSSI value measured (in units of dBm).
  */
void emberEnergyScanHandler(uint8_t channel, int8_t maxRssiValue);

/** @brief This method is called any time an event is scheduled from within an
 * ISR context. It can be used to determine when to stop a long running sleep
 * to see what application or stack events now need to be processed.
 * @param event The event that was scheduled by the ISR.
 */
void emberEventDelayUpdatedFromIsrHandler(Event *event);

/** @brief
 * This is called when the stack knows about a border router that has
 * an external route to a prefix.
 *
 * @param prefix                  external route prefix
 * @param prefixLengthInBits      length in bits of the prefix 
 * @param available               whether this external route is available.
 */
void emberExternalRouteChangeHandler(const uint8_t *prefix,
                                     uint8_t prefixLengthInBits,
                                     bool available);

/** @brief A callback that indicates whether a prior call to
 * ::emberFormNetwork() successfully initiated the form process.
 * The status argument is either EMBER_SUCCSS, or EMBER_INVALID_CALL
 * if resume was called when the network status was not EMBER_NO_NETWORK,
 * or a scan was underway.
 */
void emberFormNetworkReturn(EmberStatus status);

/** @brief
 * Provides the result of a call to ::emberGetAntennaMode.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 * @param mode the current antenna mode, 0-primary, 
 *             1-secondary, 2-toggle on tx ack fail
 */
void emberGetAntennaModeReturn(EmberStatus status,
                               uint8_t mode);

/** @brief Provides the result of a call to emberGetCcaThreshold(). */
void emberGetCcaThresholdReturn(int8_t threshold);

/** @brief
 * Gets the token information for tokenId = EMBER_CHANNEL_CAL_DATA_TOKEN
 *
 * @param lna          [msb: cal needed? | bit 0-5: lna tune value]
 * @param tempAtLna    [the temp (degC) when the LNA was calibrated]
 * #param modDac       [msb: cal needed? | bit 0-5: modulation DAC tune value]
 * @param tempAtModDac [the temp (degC) when the mod DAC was calibrated]
 */
void emberGetChannelCalDataTokenReturn(uint8_t lna,
                                       int8_t tempAtLna,
                                       uint8_t modDac,
                                       int8_t tempAtModDac);

/** @brief Provides the result of a call to emberGetCounter(). */
void emberGetCounterReturn(EmberCounterType type, uint16_t value);

/** @brief
 * Provides the result of a call to ::emberGetCtune.
 *
 * @param tune   The current CTUNE value.
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberGetCtuneReturn(uint16_t tune,
                         EmberStatus status);

/** @brief Provides the result of a call to ::emberGetDhcpClients */
void emberGetDhcpClientReturn(const EmberIpv6Address *address);

/** @brief Provides the result of a call to ::emberGetGlobalAddresses
 *
 * @param address             IPv6 global address
 * @param preferredLifetime   Preferred lifetime (in seconds)
 * @param validLifetime       Valid lifetime (in seconds)
 * @param addressFlags        Address configuration flags (EMBER_GLOBAL_ADDRESS_*)
 */
void emberGetGlobalAddressReturn(const EmberIpv6Address *address,
                                 uint32_t preferredLifetime,
                                 uint32_t validLifetime,
                                 uint8_t addressFlags);

/** @brief Provides the result of a call to ::emberGetGlobalPrefix
 *
 * @param borderRouterFlags   Border router flags (EMBER_BORDER_ROUTER_*)
 * @param isStable            Stable or temporary prefix
 * @param prefix              Border router prefix
 * @param prefixLengthInBits  Prefix length in bits
 * @param domainId            Provisioning domain ID
 * @param preferredLifetime   Preferred lifetime (in seconds)
 * @param validLifetime       Valid lifetime (in seconds)
 */
void emberGetGlobalPrefixReturn(uint8_t borderRouterFlags,
                                bool isStable,
                                const uint8_t *prefix,
                                uint8_t prefixLengthInBits,
                                uint8_t domainId,
                                uint32_t preferredLifetime,
                                uint32_t validLifetime);

/** @brief
 * Provides the result of a call to ::emberGetMfgToken.
 *
 * @param tokenId         Which manufacturing token read.
 * @param status          An EmberStatus value indicating success or the
 * @param tokenData       The manufacturing token data.
 * @param tokenDataLength The length of the <i>tokenData</i> parameter in
 *                        bytes.
 */
void emberGetMfgTokenReturn(EmberMfgTokenId tokenId,
                            EmberStatus status,
                            const uint8_t *tokenData,
                            uint8_t tokenDataLength);

/** @brief Provides the result of a call to emberGetNetworkDataTlv().
 *
 * @param type the type of TLV returned. This is the same value as
 * the value specified in the emberGetNetworkDataTlv() call.
 * @param index the instance number of the TLV. This is the same value as
 * the value specified in the emberGetNetworkDataTlv() call.
 * @param versionNumber the network data version
 * @param tlv the TLV corresponding to type or NULL.
 * @param tlvLength length of tlv
 */
void emberGetNetworkDataTlvReturn(uint8_t typeByte,
                                  uint8_t index,
                                  uint8_t versionNumber,
                                  const uint8_t *tlv,
                                  uint8_t tlvLength);

/** @brief
 * Provides the result of a call to ::emberGetPtaEnable.
 *
 * @param enabled When true, indicates packet traffic arbitration
 * is enabed. When false, indicates packet traffic arbitration is
 * disabled.
 */
void emberGetPtaEnableReturn(bool enabled);

/** @brief Provides the result of a call to emberGetRadioPower() on the host. */
void emberGetRadioPowerReturn(int8_t power);

/** @brief Provides the result of a call to emberGetRipEntry(). */
void emberGetRipEntryReturn(uint8_t index, const EmberRipEntry *entry);

/** @brief Provides the result of a call to ::emberGetRoutingLocator
 *
 * @param rloc The Routing Locator as a full IPv6 address.
 */
void emberGetRoutingLocatorReturn(const EmberIpv6Address *rloc);

/** @brief
 * Provides the result of a call to ::emberGetStandaloneBootloaderInfo.
 *
 * @param version    BOOTLOADER_INVALID_VERSION if the standalone
 *                   bootloader is not present, or the version of
 *                   the installed standalone bootloader.
 * @param platformId The value of PLAT on the node.
 * @param microId    The value of MICRO on the node.
 * @param phyId      The value of PHY on the node.
 */
void emberGetStandaloneBootloaderInfoReturn(uint16_t version,
                                            uint8_t platformId,
                                            uint8_t microId,
                                            uint8_t phyId);

/** @brief Provides the result of a call to emberGetTxPowerMode() on the host.
 * @return the current tx power mode.
 */
void emberGetTxPowerModeReturn(uint16_t txPowerMode);

/** @brief Provides the result of a call to emberGetVersions(). */
void emberGetVersionsReturn(const uint8_t *versionName,
                            uint16_t managementVersionNumber,
                            uint16_t stackVersionNumber,
                            uint16_t stackBuildNumber,
                            EmberVersionType versionType,
                            const uint8_t *buildTimestamp);

/**
* @brief In a host/NCP setup, notifies the host to changes in the network parameters.
*
* @param parameters Current network parameters
* @param localEui64 The EUI64 of the Ember chip
* @param macExtendedId The extended MAC ID of the Ember chip
* @param networkStatus The current status of the network
*/
void emberHostStateHandler(const EmberNetworkParameters *parameters,
                           const EmberEui64 *localEui64,
                           const EmberEui64 *macExtendedId,
                           EmberNetworkStatus networkStatus);

/** @brief  Provides the result of a call to emberInit(). */
void emberInitReturn(EmberStatus status);

/** @brief  A callback that indicates whether the join process was successfully
 * initiated via a prior call to ::emberJoinNetwork() or
 * ::emberJoinCommissioned().  The possible EmberStatus values are:
 * EMBER_SUCCESS, EMBER_BAD_ARGUMENT, or EMBER_INVALID_CALL (if join was called
 * when the network status was something other than EMBER_NO_NETWORK).
 */
void emberJoinNetworkReturn(EmberStatus status);

/** @brief
 * Provides the result of a call to ::emberLaunchStandaloneBootloader.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberLaunchStandaloneBootloaderReturn(EmberStatus status);

/** @brief Application handler to define "passthrough" packets.
 */
bool emberMacPassthroughFilterHandler(uint8_t *macHeader);

/** @brief Application handler to intercept "passthrough" packets and
 * handle them at the application.
 */
void emberMacPassthroughMessageHandler(PacketHeader header);

/** @brief A callback invoked when the leader data changes.
 *
 * @param leaderData the leader data
 */
void emberLeaderDataHandler(const uint8_t *leaderData);

/** @brief  Reports a change to the network status.  For example, the network
 * status changes while going through the joining process, or while reattaching
 * to the network, which can happen for a variety of reasons.  In particular,
 * after issuing a form, join, resume, or attach command, the application
 * knows that the device is on the network and ready to communicate when
 * this handler is called with a newNetworkStatus of
 * EMBER_JOINED_NETWORK_ATTACHED.
 *
 * If the status handler is reporting a join failure, then the newNetworkStatus
 * argument will have a value of EMBER_NO_NETWORK and the reason argument
 * will contain an appropriate value.  For other network status reports, the
 * reason argument does not apply and is set to EMBER_JOIN_FAILURE_REASON_NONE.
 */
void emberNetworkStatusHandler(EmberNetworkStatus newNetworkStatus,
                               EmberNetworkStatus oldNetworkStatus,
                               EmberJoinFailureReason reason);

/** @brief  If implementing event-driven sleep on an NCP host, this method will
 * return the bitmask indicating the stack's current tasks. (see enum above)
 *
 *  The mask ::EMBER_HIGH_PRIORITY_TASKS defines which tasks are high
 *  priority.  Devices should not sleep if any high priority tasks are active.
 *  Active tasks that are not high priority are waiting for
 *  messages to arrive from other devices.  If there are active tasks,
 *  but no high priority ones, the device may sleep but should periodically
 *  wake up and call ::emberPollForData() in order to receive messages.  Parents
 *  will hold messages for ::EMBER_INDIRECT_TRANSMISSION_TIMEOUT milliseconds
 *  before discarding them.
 *
 * @return A bitmask of the stack's active tasks.
 */
void emberOkToNapReturn(uint8_t stateMask);

/** @brief Provides the result of a call to emberPollForData().
 * @param An EmberStatus value:
 * - ::EMBER_SUCCESS      - The poll message has been submitted for transmission
 * - ::EMBER_INVALID_CALL - The node is not a sleepy end device.
 * - ::EMBER_NOT_JOINED   - The node is not part of a network.
 */
void emberPollForDataReturn(EmberStatus status);

/** @brief
 * Provides the result of a call to ::emberRadioGetRandomNumbers.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure. When EMBER_SUCCESS is returned 
 *               ::rn and ::count will contain valid data.  ::rn 
                 and ::count are undefined when EMBER_SUCCESS is not
 *               returned.
 * @param rn the uint16_t random values
 * @param count - the count of uint16_t values located at ::rn
 */
void emberRadioGetRandomNumbersReturn(EmberStatus status, 
                                      const uint16_t *rn, 
                                      uint8_t count);

/** @brief
 * Provides the result of a call to ::emberRequestDhcpAddress
 *
 * This call only indicates the status of the request (EMBER_ERR_FATAL if no
 * DHCP server is found, and EMBER_SUCCESS otherwise).  The assigned IPv6
 * address is returned via ::emberAddressConfigurationChangeHandler
 *
 * @param status                  Status of DHCP Address Request
 * @param prefix                  Prefix requested in ::emberRequestDhcpAddress
 * @param prefixLengthInBits      Prefix length requested in 
 *                                ::emberRequestDhcpAddress
 */
void emberRequestDhcpAddressReturn(EmberStatus status,
                                   const uint8_t *prefix,
                                   uint8_t prefixLengthInBits);

/** @brief
 * Provides the result of a call to ::emberRequestSlaacAddress
 *
 * This call only indicates the status of the request (EMBER_ERR_FATAL if no
 * SLAAC server is found, and EMBER_SUCCESS otherwise).  The assigned IPv6
 * address is returned via ::emberAddressConfigurationChangeHandler
 *
 * @param status                  Status of SLAAC Address Request
 * @param prefix                  Prefix requested in ::emberRequestSlaacAddress
 * @param prefixLengthInBits      Prefix length in bits requested in 
 *                                ::emberRequestSlaacAddress
 */
void emberRequestSlaacAddressReturn(EmberStatus status,
                                    const uint8_t *prefix,
                                    uint8_t prefixLengthInBits);

/** @brief  Notifies the application of a reset on the Ember chip
 * due to the indicated cause.
 */
void emberResetMicroHandler(EmberResetCause cause);

/** @brief Provides the result of a call to emberResetNetworkState(). */
void emberResetNetworkStateReturn(EmberStatus status);

/** @brief
 * Provides the result of a call to emberResignGlobalAddress().
 */
void emberResignGlobalAddressReturn(EmberStatus status);

/** @brief A callback that indicates whether a prior call to
 * ::emberResumeNetwork() successfully initiated the resume process.
 * The status argument is either EMBER_SUCCESS, or
 * EMBER_INVALID_CALL if resume was called when the network status was
 * not EMBER_SAVED_NETWORK, or while a scan was underway.
 */
void emberResumeNetworkReturn(EmberStatus status);

/** @brief  Provides the status upon completion of a scan. */
void emberScanReturn(EmberStatus status);

/** @brief Provides the result of a call to emberSendSteeringData(). */
void emberSendSteeringDataReturn(EmberStatus status);

/** @brief
 * Provides the result of a call to ::emberSetAntennaMode.
 *
 * @param EMBER_SUCCESS if antenna mode is configured as desired
 * or EMBER_BAD_ARGUMENT if antenna mode is not supported.
 */
void emberSetAntennaModeReturn(EmberStatus status);

/** @brief Provides the result of a call to emberSetCcaThreshold(). */
void emberSetCcaThresholdReturn(EmberStatus status);

/** @brief
 * Provides the result of a call to ::emberSetCtune.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetCtuneReturn(EmberStatus status);

/** @brief
 * Provides the result of a call to ::emberSetMfgToken.
 *
 * @param tokenId         Which manufacturing token set.
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetMfgTokenReturn(EmberMfgTokenId tokenId,
                            EmberStatus status);

/** @brief
 * Provides the result of a call to ::emberSetPtaEnable.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure.
 */
void emberSetPtaEnableReturn(EmberStatus status);

/** @brief
 * Provides the result of a call to ::emberSetRadioHoldOff.
 *
 * @param status An EmberStatus value indicating success or the
 *               reason for failure. EMBER_SUCCESS if Radio HoldOff
 *               was configured as desired or EMBER_BAD_ARGUMENT
 *               if requesting it be enabled but RHO has not been
 *               configured by the BOARD_HEADER.
 */
void emberSetRadioHoldOffReturn(EmberStatus status);

/** @brief Provides the result of a call to emberSetRadioPower() on the host. */
void emberSetRadioPowerReturn(EmberStatus status);

/** @brief Provides the result of a call to emberSetSecurityParameters(). */
void emberSetSecurityParametersReturn(EmberStatus status);

/** @brief Provides the result of a call to emberSetTxPowerMode() on the host. */
void emberSetTxPowerModeReturn(EmberStatus status);

/** @brief
 * This is called when the stack knows about a new SLAAC prefix or if
 * a SLAAC server has become unavailable.
 *
 * "available" means we can configure a SLAAC address.
 *
 * @param prefix                  SLAAC prefix
 * @param prefixLengthInBits      length in bits of the prefix
 * @param available               whether we can configure an address
 */
void emberSlaacServerChangeHandler(const uint8_t *prefix,
                                   uint8_t prefixLengthInBits,
                                   bool available);

/** @brief Provides the result of a call to emberStackPollForData(). */
void emberStackPollForDataReturn(EmberStatus status);

/** @brief Callback to tell the host to start security commissioning
 *
 * @param address parent IP address, 16 bytes
 */
void emberStartHostJoinClientHandler(const uint8_t *parentAddress);

/**
 * @brief In a host/NCP setup, provides the result of a call to emberState() on the host.
 *
 * @param parameters Current network parameters
 * @param localEui64 The EUI64 of the Ember chip
 * @param macExtendedId The extended MAC ID of the Ember chip
 * @param networkStatus The current status of the network
 */
void emberStateReturn(const EmberNetworkParameters *parameters,
                      const EmberEui64 *localEui64,
                      const EmberEui64 *macExtendedId,
                      EmberNetworkStatus networkStatus);

/** @brief
 * This can be stubbed out on the SoC and host app.  It is used by the
 * NCP to update security on the driver when it is instructed to switch
 * the network key by an over the air update.
 *
 */
void emberSwitchToNextNetworkKeyHandler(EmberStatus status);

/** @brief Provides the result of a call to emberSwitchToNextNetworkKey(). */
void emberSwitchToNextNetworkKeyReturn(EmberStatus status);

/** @brief The radio calibration callback function.
 *
 * The Voltage Controlled Oscillator (VCO) can drift with
 * temperature changes.  During every call to ::emberTick(), the stack will
 * check to see if the VCO has drifted.  If the VCO has drifted, the stack
 * will call ::emberRadioNeedsCalibratingHandler() to inform the application
 * that it should perform calibration of the current channel as soon as
 * possible.  Calibration can take up to 150ms.  The default callback function
 * implementation provided here performs calibration immediately.  If the
 * application wishes, it can define its own callback by defining
 * ::EMBER_APPLICATION_HAS_CUSTOM_RADIO_CALIBRATION_CALLBACK in its
 * CONFIGURATION_HEADER.  It can then failsafe any critical processes or
 * peripherals before calling ::emberCalibrateCurrentChannel().  The
 * application must call ::emberCalibrateCurrentChannel() in
 * response to this callback to maintain expected radio performance.
 */
void emberRadioNeedsCalibratingHandler(void);

// Called when a connection is opened to serverPort.
void emberTcpAcceptHandler(uint16_t serverPort, uint8_t fd);

void emberTcpReadHandler(uint8_t fd, uint8_t *buffer, uint16_t count);

void emberTcpStatusHandler(uint8_t fd, uint8_t status);

void emberAddAddressDataReturn(uint16_t shortId);

void emberAssertInfoReturn(const uint8_t *fileName, uint32_t lineNumber);

void emberClearAddressCacheReturn(void);

void emberConfigUartReturn(void);

void emberEchoReturn(const uint8_t *data, uint8_t length);

void emberGetMulticastEntryReturn(uint8_t lastSequence,
                                  uint8_t windowBitmask,
                                  uint8_t dwellQs,
                                  const uint8_t *seed);

void emberGetNetworkKeyInfoReturn(EmberStatus status,
                                  uint32_t sequence,
                                  uint8_t state);

void emberGetNodeStatusReturn(EmberStatus status,
                              uint8_t ripId,
                              EmberNodeId nodeId,
                              uint8_t parentRipId,
                              EmberNodeId parentId,
                              const uint8_t *networkFragmentIdentifier,
                              uint32_t networkFrameCounter);

void emberLookupAddressDataReturn(uint16_t shortId);

void emberNcpUdpStormCompleteHandler(void);

void emberNcpUdpStormReturn(EmberStatus status);

void emberResetNcpAshReturn(void);

void emberSendDoneReturn(void);

void emberSetRandomizeMacExtendedIdReturn(void);

void emberSetWakeupSequenceNumberReturn(void);

void emberStartUartStormReturn(void);

void emberStopUartStormReturn(void);

void emberUartSpeedTestReturn(uint32_t totalBytesSent,
                              uint32_t payloadBytesSent,
                              uint32_t timeout);

/** @brief  Application callback for an incoming UDP message.
 *
 * @param destination     IPV6 destination address
 * @param source          IPV6 source address
 * @param localPort       UDP source port
 * @param remotePort      UDP destination port
 * @param payload         UDP transport payload
 * @param payloadLength   payload length
 */
void emberUdpHandler(const uint8_t *destination,
                     const uint8_t *source,
                     uint16_t localPort,
                     uint16_t remotePort,
                     const uint8_t *payload,
                     uint16_t payloadLength);

/** @brief  Application callback for an incoming UDP multicast.
 *
 * @param destination     IPV6 destination address
 * @param source          IPV6 source address
 * @param localPort       UDP source port
 * @param remotePort      UDP destination port
 * @param payload         UDP transport payload
 * @param payloadLength   payload length
 */
void emberUdpMulticastHandler(const uint8_t *destination,
                              const uint8_t *source,
                              uint16_t localPort,
                              uint16_t remotePort,
                              const uint8_t *payload,
                              uint16_t payloadLength);

#endif // __THREAD_CALLBACKS__
